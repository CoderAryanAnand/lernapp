\documentclass[12pt,a4paper]{report}

% Questions to ask @Herr Schneider
% 1 -



% Packages
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage[T1]{fontenc}        % proper glyphs for äöüß, hyphenation
\usepackage[utf8]{inputenc}     % source file is UTF-8
\usepackage{lmodern}            % Latin Modern fonts
\usepackage[ngerman]{babel}     % modern German hyphenation
\usepackage[autostyle]{csquotes}
\usepackage{setspace}
\usepackage{titlesec}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{array} % for 'm' column type
\usepackage{longtable}
\usepackage{anyfontsize}
\usepackage{xurl}
\usepackage{float}
\usepackage[
backend=biber,
style=apa
]{biblatex}
\usepackage{microtype}          % better line breaking / protrusion
\usepackage[htt]{hyphenat}      % allow hyphenation in \texttt / typewriter
% Hyphenation / line-breaking tuning
\pretolerance=50
\tolerance=2000
\emergencystretch=25pt
\hyphenpenalty=100
\exhyphenpenalty=50
\doublehyphendemerits=5000
\finalhyphendemerits=1000
% Manual hyphenation exceptions (add as needed)
\hyphenation{
  Lern-zeit-al-go-rith-mus
  Lern-zeit-al-go-rith-men
  Nutz-er-da-ten
  Authen-ti-fi-zie-rung
  Prioritäts-ein-stel-lun-gen
  Pro-to-typ
  Daten-struk-tur
  Daten-struk-tu-ren
  Web-An-wen-dung
  An-wen-dungs-ar-chi-tek-tur
}
% \DeclareLanguageMapping{german}{german}
\addbibresource{references.bib}
\usepackage{etoolbox}
\makeatletter
\patchcmd{\chapter}{\if@openright\cleardoublepage\else\clearpage\fi}{}{}{}
\makeatother
\makeatletter
\renewcommand{\@makechapterhead}[1]{%
\vspace*{50 pt}%
{\setlength{\parindent}{0pt} \raggedright \normalfont
\bfseries\Huge
\ifnum \value{secnumdepth}>1 
   \if@mainmatter\thechapter.\ \fi%
\fi
#1\par\nobreak\vspace{40 pt}}}
\makeatother

% Create a command to add a footnote for AI assistance, you can add dates or versions if needed
\newcommand{\aifootnote}[1]{\footnote{ChatGPT (Version GPT-5): \enquote{Überarbeite den folgenden Text, damit er sprachlich und stilistisch den Standards einer wissenschaftlichen Maturitätsarbeit entspricht. Achte auf korrekte Grammatik, präzisen Ausdruck, logische Argumentation und sachlichen Stil. Behalte den ursprünglichen Sinn und Stil des Textes bei, aber formuliere ihn wissenschaftlicher und grammatikalisch korrekt. [...]. }, #1. Antwort ganz übernommen.}}
\newcommand{\aifootnotemark}{\footnotemark}
\newcommand{\aifootnotetext}[1]{\footnotetext{ChatGPT (Version GPT-5): \enquote{Überarbeite den folgenden Text, damit er sprachlich und stilistisch den Standards einer wissenschaftlichen Maturitätsarbeit entspricht. Achte auf korrekte Grammatik, präzisen Ausdruck, logische Argumentation und sachlichen Stil. Behalte den ursprünglichen Sinn und Stil des Textes bei, aber formuliere ihn wissenschaftlicher und grammatikalisch korrekt. [...]. }, #1. Antwort ganz übernommen.}}
\newcommand{\aifootnotebasis}[1]{\footnotetext{ChatGPT (Version GPT-5): \enquote{Überarbeite den folgenden Text, damit er sprachlich und stilistisch den Standards einer wissenschaftlichen Maturitätsarbeit entspricht. Achte auf korrekte Grammatik, präzisen Ausdruck, logische Argumentation und sachlichen Stil. Behalte den ursprünglichen Sinn und Stil des Textes bei, aber formuliere ihn wissenschaftlicher und grammatikalisch korrekt. [...]. }, #1. Antwort als Basis.}}

% Fix for font issue
\DeclareRobustCommand{\ttfamily}{\fontencoding{T1}\fontfamily{lmtt}\selectfont}

% newline after paragraph
\newcommand{\myparagraph}[1]{\paragraph{#1}\mbox{}\\}

\onehalfspacing

% Begin Document
\begin{document}


% Title Page
\makeatletter
\begin{titlepage}
    \centering
    \vspace*{1cm}
       { \includegraphics[width=6cm]{img/kanti-baden.png}}
       \addtocounter{figure}{1}
       \addcontentsline{lof}{figure}{\protect\numberline{\thefigure}{Logo der Kantonsschule Baden. Quelle: Wikipedia}}
       \\[1cm]

    {\LARGE \textbf{Kanti Koala}}\\
    {\textbf{Die Lern- und Studienhilfsapp für Schüler:innen der Kantonsschule Baden}}\\[1cm]

    {Maturitätsarbeit, Kantonsschule Baden}\\
    {Schriftlicher Kommentar}\\[1cm]
    
    \textbf{Erstbetreuer: }{Michael Schneider}\\
    \textbf{Zweitbewerterin: }{Julia Smits}\\[1cm]
    
    \textbf{Geschrieben von: }{Aryan Anand (G22b), Simon Haddon (G22b)}\\[1cm]
    \date{\large Datum: 11. November 2025}
    {\@date\\}
\end{titlepage}
\makeatother

\chapter*{Abstract}
\addcontentsline{toc}{chapter}{Abstract}
Diese Maturitätsarbeit behandelt die Konzeption und prototypische Umsetzung einer webbasierten Applikation für Schüler:innen der Kantonsschule Baden mit dem Ziel, schulische Termine, Aufgaben und Lernzeiten zentral organisierbar zu machen und regelmässige, abgegrenzte Lernphasen zu unterstützen. Die Zielsetzung umfasst keine Wirksamkeitsmessung, sondern die Bereitstellung funktionaler Grundlagen.

Zur Ableitung der Anforderungen wurden eine fokussierte Literatur- und Internetrecherche (Lernmethoden, Zeit- und Pausenorganisation, Stressaspekte), Interviews mit zwei PPP-Lehrpersonen sowie eine Umfrage unter Schüler:innen eingesetzt. Die Ergebnisse strukturierten die Funktionsprioritäten (Agenda, Lernblöcke, Noten, Timer, Tipps) und die Parametrisierung des Lernzeitalgorithmus.

Die Applikation wurde mit Python (Flask), einem relationalen Datenmodell und modularer Architektur implementiert. Kernfunktionen sind: eine Agenda mit manueller Ereigniserfassung, Import von \texttt{.ics}-Stundenplänen und algorithmischer Lernblock-Generierung nach Prioritäten; Notenverwaltung; ein konfigurierbarer Pomodoro-basiertes Lerntimer-Modul; kategorisierte tägliche Tipps, sowie auch allgemeine Lerntipps (Zeit-, Pausen-, Stressmanagement, Lernmethoden); Authentifizierung mit Basis-Schutzmassnahmen (u. a. Passwort Hashing). Der Lernzeitalgorithmus verteilt definierte Lernstunden rückwärts vom Prüfungstermin unter Berücksichtigung von Tageslimits, bevorzugten Zeiten und Konfliktvermeidung.

Die Arbeit zeigt die technische Machbarkeit eines integrierten, strukturierten Ansatzes zur Lern- und Organisationsunterstützung; Aussagen zur tatsächlichen Wirkung im Nutzungskontext stehen aus und bilden den Gegenstand zukünftiger Evaluation (z.B. Planungsaufwand, Terminnutzung, wahrgenommene Kontrolle). Der Prototyp bildet eine erweiterbare Grundlage für nachfolgende empirische Validierung. \aifootnote{06.11.2025}
\clearpage
% Table of Contents
\tableofcontents

% ------------------------------Einleitung------------------------------
\chapter[Einleitung -- unsere Vision]{Einleitung -- unsere Vision\texorpdfstring{\aifootnotemark}{}}
\aifootnotetext{04.11.2025}
Der Schulalltag an der Kantonsschule Baden ist durch eine hohe Arbeitsdichte geprägt. Neben zahlreichen Prüfungen, auf die vorzubereiten ist, fallen kontinuierlich Hausaufgaben an. In Kombination mit ausserschulischen Verpflichtungen entstehen Anforderungen an Planung und Selbstorganisation, die ohne strukturierende Hilfsmittel nur begrenzt überschaubar bleiben. 

\section{Motivation und Relevanz}
Aus unserer Erfahrung als Schüler der Kantonsschule Baden besteht ein wiederkehrendes Problem für Schüler:innen darin, Lernaufwand, Fristen und verfügbare Zeitblöcke koordiniert abzubilden. Fehlende Übersicht kann zu subjektivem Zeitdruck, Verdichtung einzelner Tage und Verschiebungen führen. Eine zentral organisierende Applikation, welche Lernzeiten, Termine und Noten gemeinsam verwaltet, ist daher relevant. In diesem Kontext wird unter Unterstützung des Selbstmanagements ausdrücklich Folgendes verstanden: (1) Reduktion des individuellen Planungsaufwands (Zeit zur manuellen Wochenplanung), (2) Erhöhung der Vorlauftransparenz (Sichtbarkeit bevorstehender Prüfungen in Tagen), (3) strukturierte Segmentierung von Lernblöcken (klar definierte Start-/Endzeiten). Die Plattformwahl (Web oder nativ) bleibt zum Untersuchungszeitpunkt offen; die Konzeption erfolgt plattformneutral.

\section{Fragestellung und Zielsetzung}
\textbf{Hauptfragestellung:}
\begin{quote}
Kann eine digitale Applikation so konzipiert und prototypisch umgesetzt werden, dass sie Schüler:innen eine übersichtliche Organisation von Terminen, Aufgaben und Lernzeiten ermöglicht und zugleich Funktionen bereitstellt, die regelmässige Lerngewohnheiten unterstützen?
\end{quote}
\textit{Begriffsklärung:} Unter „Organisation erleichtern“ verstehen wir eine bessere Übersicht über anstehende Termine/Aufgaben und eine Verringerung des manuellen Planungsaufwands. „Lerngewohnheiten unterstützen“ meint Funktionen, die regelmässige, zeitlich abgegrenzte Lernphasen fördern (z. B. Lernblöcke und Timer).\\

\noindent
\textit{Zielsetzung:} Entwicklung eines Prototyps, der die zur Messung dieser Indikatoren notwendigen funktionalen Strukturen (Agenda mit Prioritäten, Lernblock-Generierung, Notenerfassung, Timer) bereitstellt.

\section{Aufbau und Begründung des schriftlichen Kommentars}
Der Bericht ist entlang der Entwicklungslogik aufgebaut und führt von der Ausgangslage über die Umsetzung zur Einordnung:
\begin{enumerate}
  \item \textbf{Recherche}: TBA
  \item \textbf{Methodik - Programmierung}: Systemarchitektur, Datenstrukturen, Darstellung der Features, Sicherheitsaspekte und schliesslich noch Testing.
  \item \textbf{Schlussfolgerung und Ausblick}: Bilanz zur Fragestellung, gewonnene Erkenntnisse und offene Arbeitsschritte.
\end{enumerate}
Die Gliederung macht nachvollziehbar, wie aus Problemstellung und Zielsetzung konkrete Komponenten abgeleitet, implementiert und dokumentiert wurden; eine empirische Wirkungsevaluation ist nicht Gegenstand dieses Berichts.

% ------------------------------Recherche------------------------------
\chapter{Recherche}
\section{Einführung}
\subsection{Warum brauchen wir eine Recherche?}
Da wir eine Web-App erstellen wollen, welche möglichst gut an die Bedürfnisse von Schüler:innen angepasst ist, durften wir uns nicht nur auf unsere eigenen Erfahrungen als Schüler verlassen, sondern mussten auch ein gewisses Mass an Recherche erledigen, damit wir wichtige Entscheidungen sinnvoll begründen konnten. 
Zu diesem Ende haben wir uns entschieden, uns tiefgründig mit unserem Zielpublikum - Schüler:innen der Kantonsschule Baden - auseinanderzusetzen, indem wir Interviews mit PPP-Lehrpersonen führten und eine Umfrage für Schüler:innen gestalteten.

Die Recherche stellt hier nicht das Kernstück unserer Arbeit dar, sondern ist ein unterstützender, aber dennoch sehr wichtiger, Bestandteil für die Entwicklung der Web-Applikation, da sie uns hilft, uns in unsere Zielgrupe zu versetzen und ihre Bedürfnisse
Wir setzten einen starken Wert auf begründete Entscheidungen und strebten eine möglichst hohe Qualität an.

\subsection{Was recherchieren wir?}
Nun ging es zuerst einmal darum, herauszufinden was wir überhaupt recherchieren wollten. 
Da unsere Web-Applikation das Lernen fördern soll, stand der Kernpunkt, nämlich das Lernen, schon von Anfang an klar.

Um genaue Recherche-Themen auszusuchen, stellten wir einige W-Fragen zum Lernen:
\begin{itemize}
    \item Wie oder warum lernt man gut?
    \item Wann lernt man gut oder nicht gut?
    \item Was hindert das Lernen?
\end{itemize}

Somit entstanden unsere vier Hauptbereiche, welche die obigen drei Fragen beinhalten: Lerntechniken, das Pausen- und Zeitmanagement und das Stressmanagement.

Aufgrund unserer geplanten Features für die Web-Applikation, wie die Agenda oder der Lerntimer, wussten wir auch schon, dass das Zeitmanagement besonders wichtig sein wird.

\subsection{Wie führen wir die Recherche durch}

Uns war klar, dass wir, da wir uns möglichst tief in unser Zielpublikum versetzen, uns hauptsächlich auf die Meinungen von Personen in und im Umfeld unserer Zielgruppe.
Somit standen persönlichere Methoden, wie Interviews und Umfragen, schon früh in Erwägung.

Wir entschieden uns also nach Rücksprache mit unserem Erstbewerter, die Recherche in drei wesentliche Teile zu teilen: 
\begin{itemize}
    \item Eine begrenzte Literaturstudie, welche uns in das Thema einführen und ein wenig vertrauter mit der Materie machen soll.
    \item Darauf aufbauend führen wir Interviews mit Expert:innen, um diese Materie konkret zu vertiefen und, wenn möglich, auf das Zielpublikum zu beziehen.
    \item Durch Feedback aus den vorherigen Schritten bereiten wir eine Umfrage für unser Zielpublikum vor, welches uns Daten aus der Sicht der Schüler:innen liefern soll.
\end{itemize}

Somit können wir anhand dieser Strategie das Wissen, welche wir in der Literaturstudie auffinden, in den Interviews vertiefen, mit unserem gewünschten Umfeld vergleichen und dann gezielt in der Umfrage mit der Praxis vergleichen.
Dies sollte uns erlauben, einiges an nützlichen Informationen für unsere Web-Applikation zu erhalten und daraus wichtige Entscheidungen zu treffen.

\section{Literaturstudie}
\subsection{Ziel}
Da die Literaturstudie als Unterstüztung für die anderen, für uns weitaus wichtigeren Elemente unserer Recherche gedacht war, lag nicht besonders viel Fokus darauf.
Ziel war, hier ein kleines Stückchen an grundlegendem Wissen zu erreichen ohne dass wir komplett in der Materie verloren gehen und die Übersicht über was tatsächlich für unsere Arbeit nötig ist verlieren.

\subsection{Vorgehensweise}
Die Literaturstudie ist hauptsächlich aus zwei Teilen aufgebaut: Eine breitere Internet-Recherche um ein gewisses Basiswissen zu erreichen, und einen tieferen Einblick in zwei Sachtexte zum Lernen.
Dieses kombinierte Basiswissen fliesst dann direkt in die Vorbereitung für die Interviews hinein.

\subsection{Internet-Recherche}

Wie erwähnt, ging es hier primär um den Aufbau eines Grundsatzes an Vorwissen, welches wir an unserer bisherigen Erfahrung als Kantischüler anhängen können.
Somit fokussierten wir uns nicht darauf, möglichst breite und diverse Quellen einzuholen, sondern darauf, dass wir dieses Vorwissen einigermassen effizient aufbauen können. 
Daraus merkten wir, dass nicht viel nötig war, um dies zu erlangen.

\subsubsection{Lerntechniken und -methoden}
Eines der ersten interessanten Einblicke welche wir fanden, war der Unterschied zwischen den Fachbegriffen \enquote{Lernmethode} und \enquote{Lerntechnik}.

Nämlich besteht da der wesentliche Unterschied darin, dass Lerntechniken einzelne spezifische Schritte im Lernprozess sind, während eine Lernmethode eine Kollektion von Lerntechniken darstellt und die allgemeine Lernstrategie beschreibt.\footcite{Lerntechnik_1}
Dabei wurden wir auf ein paar wenige Lernmethoden und -techniken aufmerksam, welche angeblich das Lernen vereinfachern sollten, wie beispielsweise die Lernmethoden SQ3R\footcite{SQ3R} oder KWL\footcite{SQ3R}, während eine Lerntechnik beispielsweise das Erschaffen von Verknüpfung zu bestehendem Wissen darstellt. 
Diese wurden hauptsächlich von \textcite{SQ3R} übernommen.

\subsubsection{Zeit- \& Pausenmanagement}
Dieses Thema war schon von Anfang an wichtig für uns, vor allem wegen unseren Agenda- und Lerntimer-features, also haben wir hauptsächlich im Bereich des Lerntimers, auch bekannt als der \enquote{Pomodoro-Timer}, und die Zeiteinplanung recherchiert.

Zur erfolgreichen Zeiteinteilung gehört für uns auch die Fähigkeit, sinnvoll Pausen zu machen, weswegen wir auch Informationen zu wann und wie man Pausen machen soll recherchierten.
Dies war für uns vor allem wichtig, da wir in unserem Umfeld auch dies immer wieder als Problem beobachtet haben.

\subsubsection{Umfragedesign}
Da wir später eine Umfrage für die Schüler:innen der Kantonsschule Baden erstellen wollten, war es für uns wichtig, dass wir auch das Umfragedesign berücksichtigen.
Der Hauptteil der Informationen dafür kam nicht aus dem Internet, sondern aus einem Lehrmittel\footcite{umfrageDesign}, welches wir netterweise von den PPP-Lehrpersonen Frau Suter und Herr Schmocker erhalten hatten.
Da war hauptsächlich das Kapitel \texttt{\enquote{Sozialwissenschaftliche Methoden" (S. 191 - 218)}}


\subsection{Literatur}
Für die Literaturstudie liehen wir die folgenden zwei Bücher aus, welche uns einen differenzierten Standpunkt geben sollten:
\begin{itemize}{}
    \item \texttt{Effektiver Lernen für Dummies (2. Auflage) \parencite{Book1} von Dr. Birgit Ebbert}
    \item \texttt{Lernpsychologie (6. Auflage) \parencite{Book2} von Walter Edelmann}
    
\end{itemize}
Diese zwei Bücher sollten uns einen guten Überblick über das Lernen aus zwei verschiedenen Perspektiven - der direkten Anwendung mit \enquote{Effektiver Lernen für Dummies} und der wissenschaftlichen Perspektive mit \enquote{Lernpsychologie} - geben. 
Dabei führten wir laufend Notizen und integrierten diese in unser Interviewfragendossier \& unsere Umfrage, welche in \texttt{Abschnitt 2.3 \& 2.4} näher beschrieben werden.

In den Büchern lernten wir viel über was einen guten Lernerfolg voraussetzt.
Dazu gehören unter anderem verschiedene Lerntechniken \& -strategien, wie man sich erfolgreich auf eine Prüfung vorbereitet und die Bedeutung von einem guten Lernumfeld, d.h. alle Faktoren um das éernen welche dies unterstützen.
Unter anderem beinhaltet dies, dass man einen guten Schlafrhythmus hat, genug sinnvolle Pausen macht, und auch psychologische Faktoren wie ein gutes Mindset. 
Auch ein paar wenige wissenschaftliche Begriffe waren für uns wichtig, darunter das sogenannte \enquote{Assoziationslernen}.\footcite{Book2}. 
Unter dem Assoziationslernen versteht \textcite{Book2} das Lernen durch der Schaffung von Verknüpfungen zu bisher gelerntem Wissen. 
Somit kann das Gehirn einfacher neues Wissen aufnehmen und verarbeiten.

Insgesamt konnten wir so unser Vorwissen zu unseren für uns wichtigen Themenbereichen noch um einiges ausbauen, damit wir uns noch besser auf die Interviews vorbereiten konnten.

v-- OLD TEXT --v

\section{Interviews}

\subsection {Vorgehensweise}
Wir wussten, das ein wichtiger Aspekt unserer Recherche Interviews mit Expert:innen sein würden, da sie uns vermutlich am Besten weiterhelfen könnten, da sie sich gut mit dem Thema auskennen und viel persönliche Erfahrungen mitbringen.
Somit können sie auch direkt auf unsere Fragen eingehen und uns auch für die Umfrage persönlich Feedback geben. 

Zu diesem Ende wählten wir zwei PPP-Lehrpersonen der Kantonsschule Baden, Frau Suter und Herr Schmocker, aus. Sie haben beide extensive Erfahrung mit der Lernpsychologie und, dank ihrer Tätigkeit als Lehrpersonen, auch viel Kontakt mit Kantischüler:innen.
Deswegen stellten sie die idealen Interviewpartner für uns dar. Wir hatten bereits durch unserem Erstbetreuer, Herr Schneider, zwei Theorie-Dokumente erhalten, welche uns mit der Umfragetheorie und der Durchführung von Interviews helfen sollte.

\subsubsection {Themenwahl}
Wir wollten uns hauptsächlich auf die folgenden vier Themen konzentrieren:
\begin{itemize}
    \item Lernmethoden \& -techniken
    \item Stressmanagement
    \item Pausenmanagement
    \item Zeitmanagement
\end{itemize}

Diese Themen wählten wir, da wir sie als wichtig für den Schulalltag und das Lernen empfanden und somit auch als besonders relevant für unsere Web-Applikation sahen,
da wir dies darin einbauen könnten. Dies geht am einfachsten beim Zeitmanagement, da dies sehr stark in unsere geplanten Agenda- und Pomodoro-Timer-Features einfliesst, aber vor allem unsere geplanten Lern- und Daily-Tipps sind da besonders versatil.


Bei all diesen Themen haben wir auch schon einen persönlichen Bezug dank unserer bisherigen Schulkarriere, und können so uns auch auf unsere eigenen Erfahrungen und Unsicherheiten stützen.
Als Letztes haben wir dann auch nach Feedback für unsere Umfrage eingefügt, da wir professionelles Feedback dafür einholen wollten und das Interview dafür die beste Gelegenheit ist, vor allem da die PPP-Lehrpersonen uns schon das Theorie-Dokument zum Umfragedesign zur Verfügung gestellt hatten.

\subsection {Interviewfragebogen \& Interviewfragen}
Um sowohl uns selbst als auch die Interviewpartner auf das Interview adequat vorzubereiten, erstellten wir einen Interviewfragebogen, in dem all unsere geplanten Fragen aufgelistet sind.
Die Fragen wurden nach den vier Themenblöcken geordnet und nummeriert, um eine klare Struktur zu erstellen, in der das Interview verlaufen soll.

Die jeweiligen Fragen haben wir gesammelt, indem wir uns einerseits überlegten, wo wir Unsicherheiten sahen oder generell mehr wissen wollte, andererseits wo ein genauer Bezug zu den Schüler:innen der Kantonsschule Baden oder die persönlichen Erfahrungen der Interviewpartner wichtig sein könnten. 
Ebenfalls benutzten wir ChatGPT um ein paar Vorschläge zu generieren, jedoch sind alle Fragen selbstständig ausgedacht und formuliert worden. (Vergleich \textit{KI Nachweis}) 

\subsubsection {Interviewfragen: Lernverhalten}
Als Erstes überlegten wir uns theoretische Fragen zum Lernverhalten allgemein, aufgeteilt in \texttt{Lernmethoden} \& \texttt{Lerntechniken}. 
Hier wird nochmals der Unterschied zwischen einer Lernmethode und Lerntechnik wichtig. 
Wie bereits in \texttt{Abschnitt 2.2.2} beschrieben, ist eine Lernmethode eine allgemeine Strategie zum Lernen und kann von mehreren Techniken gebrauch machen, während eine Lerntechnik ein spezifisches Element des Lernens darstellt \parencite{Lerntechnik_1}.


\myparagraph{Lernmethoden}
Zum Thema Lernmethoden überlegten wir uns zwei sehr spezifische Fragen:
\begin{itemize}
    \item Was sind, Ihrer Meinung nach, die besten Lernmethoden für Schulstoff?
    \item Was halten Sie von Lernmethoden wie \enquote{SQ3R} (\enquote{Survey, Question, Read, Recite, Review}) oder \enquote{KWL} (\enquote{Know, Want, Learn})? Sind solche Methoden Ihrer Meinung nach für den Schulalltag sinnvoll?
 \end{itemize}

 Mit diesen Fragen wollten wir nach spezifischen Lernmethoden nachforschen, und die Meinung der Interviewpartner dazu herausfinden. 
 Dies da, wenn sich solche als sinnvoll herausstellen würden, diese eventuell in die Web-Applikation integriert oder, beispielsweise, speziell erklärt werden könnten.
 Somit konnten wir auch die erwähnten Lernmethoden aus der Internet-Recherche hineinarbeiten.

\myparagraph{Lerntechniken}
Die Lerntechniken stellten mit fünf Fragen das umfangreichste Segment des Interviewfragebogens dar:
\begin{itemize}
    \item Wie sehr variiert, welche Lerntechniken am besten funktionieren, von Person zu Person?
    \item Welche Lerntechniken sind generell am nützlichsten, um das Gelernte so gut wie möglich zu verinnerlichen?
    \item Was sind Ihre \enquote{Geheimtipps} für das Lernen von Schulstoff?
    \item Inwiefern hat das \enquote{Mindset} etwas mit dem Lernen zu tun, und wie kann man das \enquote{Mindset} verbessern, beziehungsweise was macht ein gutes \enquote{Mindset} aus.
    \item Macht das Fach, für welches man lernt, einen Unterschied in welche Lerntechnik man verwenden sollte, oder gibt es eine \enquote{universelle} Methode welche für alles anwendbar ist. 
\end{itemize}

Hier ging es uns darum, anstatt spezifische Techniken zu erforschen, was für eine individuelle Person am Besten funktionieren würde.
Das grundlegende Ziel war natürlich immernoch, herauszufinden, wie man dies in die Web-Applikation integrieren kann. 
Beispielsweise wäre es schlau, wenn nun ganz klar eine spezifische Technik empfohlen wird, diese Technik, ähnlich wie beispielsweise die Pomodoro-Technik für das Zeitmanagement, einzubauen.

Besonders interessiert waren wir am sogenannten \enquote{Mindset} und den persönlichen Tipps der Interviewpartner:innen, da diese uns womöglich einen guten Einblick in die Materie aufgrund ihrer eigenen Erfahrung als Lehrperson geben könnten.
Natürlich sind alle Fragen auch besonders relevant für unsere Lerntipps.

\subsubsection{Interviewfragen: Pausenmanagement}
Dieser Abschnitt ist vor allem für unseres geplantes \enquote{Pomodoro}-Feature wichtig, hat aber auch eine Relevanz für unsere Lerntipps. 
Somit stellten wir die folgenden drei Fragen:
\begin{itemize}
    \item Was sind gute Anzeichen, dass man beim Lernen eine Pause braucht?
    \item Wie lange sollte eine Pause während dem Lernen sein und was für Faktoren könnten die \enquote{ideale} Pausenlänge beeinflussen?
    \item Ist es besser, Pausen fix einzuplanen oder sie \enquote{nach Gefühl} durchzuführen?
\end{itemize}

Somit lag der Hauptfokus darauf, festzulegen wann und wie Lange eine Pause sein soll, anstatt auf wie man sie verbringen sollte.

\subsubsection{Interviewfragen: Stressmanagement}
Das Stressmanagement war ein für uns durch persönliche Erfahrungen bereits sehr vertrautes Problem und eines, welches wir so gut wie möglich in unsere Lerntipps einbauen wollten. 
Ob und wie andere Schüler:innen oft Stress empfinden, wollten wir mit der Umfrage herausfinden, weswegen es auch hier hauptsächlich um die Erfahrungen der Lehrpersonen und um ihre Empfehlungen, wie man Stress abbauen kann, geht.
Daraus entstanden diese zwei Fragen:

\begin{itemize}
    \item Was sind die häufigsten Gründe für Prüfungsstress in der Schule und vor Prüfungen, welche Sie hier an der Kantonsschule Baden beobachtet haben?
    \item Was sind Ihre empfohlenen Methoden, um Stress abzubauen.
\end{itemize}

\subsubsection{Interviewfragen: Zeitmanagement}
Als letztes Segment mit konkreten Fragen kam das Zeitmanagement. Auch dies stellte sich für uns als ein vertrautes Problemfeld dar, vor allem wegen der Prokrastination. 
Hier ging es uns aber im Interview hauptsächlich darum, herauszufinden wie man die Zeit ausserhalb des Stundenplans einteilen sollte, was auch für unseren Agenda-Algorithmus von grosser Bedeutung ist. 
Auch fragten wir hier zur Pomodoro-Methode nach, da wir auch die persönlichen Meinungen der Interviewpartner:innen in Bezug nehmen wollten, da sie als Lehrpersonen das Umfeld an der Kanti Baden sehr gut kennen. 
Somit haben wir also folgende Fragen ausgewählt:

\begin{itemize}
    \item Haben Sie schon einmal vom sog. \enquote{Pomodoro-Timer} gehört, und wenn ja - was halten Sie davon?
    \item Was haben Sie für Tipps, um mit der Zeitplanung eine Balance zwischen Freizeit und Schule/Lernen zu gestalten?
    \item Was für ausserschulische Leistungserwartungen sind für Schüler Ihrer Meinung nach realistisch?
    \item Soll das Lernen am Wochenende Ihrer Meinung nach vermieden oder gefördert werden?
\end{itemize}

\subsubsection{Umfragedesign}
Ganz am Schluss wollten wir noch das Umfragedesign besprechen. Hierzu gibt es keine konkreten Fragen, sondern es ging uns darum, genaues Feedback von den Interviewpartner:innen zu unserer bisher erstellten Umfrage einzuholen, damit wir diese so verbessern können.
Dabei achteten wir uns vor allem auch auf das Umfrage-Layout und die Art der Fragen, welche wir in der Umfrage einbauten.

\subsection {Durchführung}
Wir wussten schon früh, wer wir als unsere Interviewpartner:innen haben wollten. 
Wir haben uns zwei PPP-Lehrpersonen der Kantonsschule Baden ausgesucht, nämlich Herr Schmocker und Frau Suter, von welchen wir auch durch unseren Erstbewerter Theoriedokumente zum Umfrage- und Interviewdesign erhalten haben.

Somit luden wir diese zwei Lehrpersonen per E-Mail zum Interview ein, vereinbarten ein Datum und schickten ihnen jeweils etwa eine Woche vor dem Interview den fertiggestellten Interviewfragebogen und einen Link zu unserer Umfrage, damit sie sich gut vorbereiten konnten.
Die vereinbarten Daten waren der \texttt{24. April 2025} mit Frau Suter und der \texttt{8. Mai 2025} mit Herr Schmocker.

Die Interviews führten wir in einem reservierten Klassenzimmer an der Kantonsschule Baden, jeweils am Mittag um \texttt{12:15} durch, mit einer Dauer von je etwa einer Stunde.
Diese wurden mit der Erlaubnis der Interviewpartner aufgenommen, damit sie später besser transkribiert und analysiert werden können und schrieben nebenbei reichliche Notizen.
Ein Fehler, welcher uns hier unterlief, war, dass wir die Interviews auf Mundart führten, welches diese spätere Analyse um einiges erschwerte.

Nach dem Interview mit Frau Suter tauschten wir uns noch per E-Mail aus, um weiteres Feedback für die Umfrage, welche nach dem Feedback aus den Interviews ergänzt wurde, zu gewinnen.

\subsection {Transkription}
Als erster Schritt der formellen Analyse der Interviews transkribierten wir die jeweiligen Audio-Aufnahmen der Interviews auf Papier als Word-Dateien, um die spätere detailierte Analyse zu erleichtern.
Dies war, wie in \hyperlink{Durchführung}{Durchführung} erwähnt, aufgrund der Verwendung von Mundart nicht sehr einfach, da dies aufgrund des Mangels an Mundart-Übersetzern nun komplett manuell vorlaufen musste.

Somit wurde das Gesprochene auf Hochdeutsch übersetzt und allfällige sprachliche Füller wie beispielsweise \enquote{ähm} wurden entfernt.
Wir achteten uns immer genau darauf, dass klar ist wer wann spricht. 
Zu diesem Ende wurden Textabschnitte geformt, indem alles, was eine Person zu einem Zeitpunkt ununterbrochen sagt, zusammengefügt wurde.
Dies sah dann beispielsweise folgendermassen aus:

\begin{quote}
    \textbf{[3:27]
Frau Suter:} Von den effektiven Zeiten bin ich ein wenig überfragt. Ich kann mir vorstellen, dass es auch wieder draufankommt, um was es nun genau geht. 

\end{quote}

Die Zeitangabe signifiert, wann der gesprochene Abschnitt anfängt, damit man ihn zur Überprüfung leicht wiederfinden kann und die Person wer die Aussage getroffen hat.
Ebenso haben wir uns als Hilfe notiert, wann in etwa welche Frage / welches Thema diskutiert wird.

\subsection {Analyse}
In der Analyse ging es uns um dreierlei: Direkte Antworten und Aussagen zu unseren Fragen, allgemeine nützliche Informationen zum Lernen und allgemeine nützliche Informationen zur Web-Applikation.
Diese sammelten wir durch genaue Analyse der schriftlichen Transkription, dabei wurde immer für spätere Referenz auch auf die genaue Textquelle vermerkt. 


\section{Umfrage}


% ------------------------------Programmieren------------------------------
\chapter{Methodik -- Programmieren der Web-Applikation}
\section[Erste Entscheidungen]{Erste Entscheidungen\texorpdfstring{\aifootnotemark}{}}
\aifootnotetext{04.11.2025}
Zu Beginn stand die grundsätzliche Plattformwahl im Zentrum: native Applikation (z.\,B. für Smartphones) oder webbasierte Lösung. Unter Berücksichtigung von Geräteunabhängigkeit, Verteil- und Updateaufwand, Entwicklungsressourcen sowie des verfügbaren Zeitrahmens erwies sich eine Web-Applikation als zweckmässig. Sie ist plattformagnostisch im Browser nutzbar, benötigt keine Installation und lässt sich zentral aktualisieren. Zudem reduziert eine einheitliche Codebasis den Implementierungs- und Wartungsaufwand gegenüber mehreren nativen Anwendungen für unterschiedliche Betriebssysteme.

Auf Basis dieser Entscheidung fiel die Wahl der Technologie auf Python mit dem Microframework Flask. Ausschlaggebend waren vorhandene Vorkenntnisse. Als Entwicklungsumgebung wurde Visual Studio Code verwendet, da es durch integrierte Funktionen wie Code-Assistenz (z. B. Copilot) einen effizienten Entwicklungsprozess ermöglicht und schnelle Unterstützung bietet.

Für die kollaborative Arbeit kamen Git als Versionsverwaltung und GitHub als zentrales Remote-Repository zum Einsatz. Der Quellcode wurde dort gemeinsam versioniert und ausgetauscht; regelmässige Synchronisationen (Push/Pull) stellten einen konsistenten, aktuellen Projektstand sicher.

% HIER MUSS NOCH SERVER ENTSCHEIDUNG GESCHRIEBEN WERDEN

% ------------------------------ANFORDERUNGEN------------------------------
\section[Anforderungen]{Anforderungen\texorpdfstring{\aifootnotemark}{}}
\aifootnotetext{04.11.2025}
Bevor wir mit dem Programmieren der Web-Applikation beginnen konnten, mussten wir uns zuerst über die Anforderungen an die Applikation klar werden. Da es sich um eine Web-Applikation handelt, welche den Schüler:innen der Kantonsschule Baden helfen soll, mussten wir uns überlegen, welche Funktionen die Applikation beinhalten sollte und wie diese umgesetzt werden könnten.

Die Anforderungen an die Kanti Koala Web-Applikation sind wie folgt:
\begin{itemize}
    \item \textbf{Home-Screen}: Von dem Home-Screen sollte man auf seinen Account und die Agenda zugreifen können. Zusätzlich sollte hier jeden Tag ein allgemeiner Tipp für die Kantonsschule angezeigt werden.
    \item \textbf{Account Management}: Die Nutzer:innen sollten sich registrieren, einloggen, ihr Passwort zurücksetzen und ihre Account-Einstellungen ändern können. Sie sollten die Möglichkeit haben, ihr Passwort zu ändern und allfälligerweise ihr Account zu löschen. 
    \item \textbf{Agenda}: Die Nutzer:innen sollten ihren Stundenplan eintragen können, sowoul manuell wie auch durch den Import einer .ics-Datei. Ebenso sollte man neue Erreignisse eintragen können. Die Erreignisse sollten veränderbar sein. Die Farbe der Erreignisse sollten auch frei bestimmbar sein. Die Agenda sollte auch einen Lernzeitalgorithmus beinhalten, welcher automatisch Lernzeiten basierend auf den eingetragenen Erreignissen und den Prioritätseinstellungen der Nutzer:innen plant.
    \item \textbf{Notenverwaltung}: Die Nutzer:innen sollten ihre Noten für jedes Fach eintragen können. Die Noten sollten veränderbar und löschbar sein. Die Nutzer:innen sollten auch ihre Semester verwalten können, indem sie neue Semester hinzufügen, bestehende Semester bearbeiten und löschen können.
    \item \textbf{Lerntimer}: Die Nutzer:innen sollten einen Pomodoro-Timer verwenden können, um ihre Lernzeiten zu strukturieren. Der Timer sollte anpassbar sein, sodass die Nutzer:innen die Länge der Lern- und Pausenintervalle einstellen können.
    \item \textbf{UI}: Die Web-Applikation sollte ein benutzerfreundliches und ansprechendes UI haben, welches einfach zu navigieren ist.
\end{itemize}

% ------------------------------Technische Dokumentation------------------------------
\section[Technische Dokumentation (System- und Datenstruktur)]{Technische Dokumentation (System- und Datenstruktur)\texorpdfstring{\aifootnotemark}{}}
\aifootnotetext{04.11.2025}
Dieser Abschnitt beschreibt die technische Grundlage der Kanti Koala Web-Applikation, einschliesslich der Systemarchitektur, der Datenstruktur und der Code-Struktur, wie es auch implementiert wurde.

\subsection{Darstellung der Systemarchitektur}
Die Kanti Koala App ist als monolithische Webanwendung konzipiert, die auf einem zentralen Backend-Server läuft.

\begin{itemize}
    \item \textbf{Frameworks:}
    Das Kernstück der Anwendung ist das Python-Microframework Flask. Es steuert das Routing (die Zuordnung von URLs zu Funktionen), verarbeitet HTTP-Anfragen (GET, POST, usw.) und rendert die HTML-Templates für den Benutzer.

    \item \textbf{Komponentenübersicht (Wichtige Pakete):}
    \begin{itemize}
        \item \textbf{Flask-SQLAlchemy}: Dient als Object-Relational Mapper (ORM) für die Datenbank. Es ermöglicht die Definition von Datenbanktabellen als Python-Klassen (Models) und vereinfacht Datenbankabfragen.
        \item \textbf{Flask-Bcrypt}: Wird für die Sicherheit der Benutzerpasswörter eingesetzt. Es hasht und verifiziert Passwörter mithilfe des bcrypt-Algorithmus.
        \item \textbf{Flask-Migrate}: Erleichtert Schema-Migrationen der Datenbank, wenn sich die Modelle (Tabellenstruktur) ändern.
        \item \textbf{Resend}: Dient als E-Mail-API für den Versand von systemgenerierten E-Mails, insbesondere für die \enquote{Passwort vergessen}-Funktion.
        \item \textbf{icalendar}: Eine Python-Bibliothek, die zum Parsen und Importieren von \texttt{.ics}-Kalenderdateien verwendet wird, um den Schulnetz-Stundenplan zu importieren.
        \item \textbf{itsdangerous}: Wird verwendet, um sichere, zeitlich begrenzte Tokens zu generieren, die für die \enquote{Passwort zurücksetzen}-Links benötigt werden.
    \end{itemize}

    \item \textbf{Server-Setup:}
    \begin{itemize}
        \item Die Anwendung ist für den Betrieb auf DigitalOcean, einer Cloud-Platform, ausgelegt.
        \item Die Datenbankkonfiguration und verschiedene Schlüssel/API Keys werden dynamisch über Umgebungsvariablen geladen.
        \item Der Code unterstützt sowohl PostgreSQL (für die Produktion auf Cloud-Diensten) als auch SQLite (für wenn wir lokal entwickeln).
    \end{itemize}
\end{itemize}

\subsection{Beschreibung der Datenbank(en) und Datenstruktur}
Die Datenstruktur ist in der Datei \texttt{models.py} durch SQLAlchemy-Modelle definiert. Eine detaillierte Beschreibung der einzelnen Tabellen (\texttt{User}, \texttt{Settings}, \texttt{PrioritySetting}, \texttt{Event}, \texttt{Semester}, \texttt{Subject}, \texttt{Grade}) und ihrer Attribute ist im Abschnitt \enquote{Datenbankmodelle und Schema} ausführlicher dokumentiert.

\begin{itemize}
    \item \textbf{Tabellen:}
    Die Datenbank besteht aus sieben Haupttabellen: \texttt{User}, \texttt{Settings}, \texttt{PrioritySetting}, \texttt{Event}, \texttt{Semester}, \texttt{Subject} und \texttt{Grade}, die direkt den SQLAlchemy-Klassen in \texttt{models.py} entsprechen.

    \item \textbf{Beziehungen (Relationships):}
    Die Beziehungen werden durch \texttt{db.relationship} und \texttt{db.ForeignKey} in den Modellen verwaltet.
    \begin{itemize}
        \item \textbf{User-zentrierte Struktur:} Der \texttt{User} ist das zentrale Modell. Alle anderen Hauptdaten sind direkt oder indirekt mit ihm verknüpft:
        \begin{itemize}
            \item \texttt{User} (1) $\to$ \texttt{Settings} (1)
            \item \texttt{User} (1) $\to$ \texttt{Event} (N)
            \item \texttt{User} (1) $\to$ \texttt{Semester} (N)
        \end{itemize}
        \item \textbf{Hierarchische Beziehungen:}
        \begin{itemize}
            \item \texttt{Settings} (1) $\to$ \texttt{PrioritySetting} (N): Jede Einstellung hat mehrere Prioritätsregeln.
            \item \texttt{Semester} (1) $\to$ \texttt{Subject} (N): Jedes Semester hat mehrere Fächer.
            \item \texttt{Subject} (1) $\to$ \texttt{Grade} (N): Jedes Fach hat mehrere Noten.
        \end{itemize}
        \item \textbf{Kaskadierendes Löschen:} Die Beziehungen sind mit \texttt{cascade=\char`\"all, delete-orphan\char`\"} konfiguriert. Das bedeutet, wenn ein übergeordnetes Objekt (z.B. ein \texttt{User} oder ein \texttt{Semester}) gelöscht wird, werden alle zugehörigen untergeordneten Objekte (z.B. alle \texttt{Events} und \texttt{Settings} des Users) automatisch mitgelöscht. Dies stellt die Datenintegrität sicher.
    \end{itemize}
\end{itemize}

\subsection{Code-Struktur}
Um die Wartbarkeit und Skalierbarkeit der Anwendung zu verbessern, wurde die ursprüngliche Code-Struktur von einer einzigen \texttt{app.py}-Datei in ein modulares Python-Paket namens \texttt{kkoala} umstrukturiert. Dieser Ansatz folgt dem \enquote{Application Factory}-Pattern, einer bewährten Methode für Flask-Anwendungen. Zudem ist diese Anwendung auch die Best Practice für Flask-Anwendungen. \parencite{flask_structure_best_practices}

\begin{enumerate}
    \item \textbf{Das \enquote{Application Factory}-Pattern (\texttt{kkoala/\_\_init\_\_.py})}:
    Das Herzstück des Pakets ist die \texttt{create\_app}-Funktion. Anstatt einer globalen App-Instanz wird die Anwendung durch diesen \enquote{Factory}-Aufruf erzeugt. Dies ermöglicht es, verschiedene Konfigurationen (z.B. für Entwicklung, Test oder Produktion) dynamisch zu laden und macht die Anwendung robuster. In dieser Datei werden auch die Flask-Erweiterungen initialisiert und die Blueprints registriert.

    \item \textbf{Konfiguration (\texttt{kkoala/config.py})}:
    Diese Datei enthält Konfigurationsklassen (z.B. \texttt{DevConfig}, \texttt{ProdConfig}). Sie verwalten wichtige Einstellungen wie den \texttt{SECRET\_KEY}, die Datenbank-URL und API-Schlüssel. Die Konfiguration wird je nach Umgebungsvariable beim Start der App ausgewählt.

    \item \textbf{Blueprints für Routen (\texttt{kkoala/routes/})}:
    Die Routen der Anwendung sind in \enquote{Blueprints} aufgeteilt, die eine Gruppierung von zusammengehörigen Endpunkten ermöglichen. Dies sorgt für eine saubere Trennung der Anwendungslogik:
    \begin{itemize}
        \item \textbf{\texttt{auth.py}}: Enthält alle Routen für die Benutzerauthentifizierung (Login, Registrierung, Passwort zurücksetzen).
        \item \textbf{\texttt{events.py}}: Verwaltet die API-Endpunkte für die Agenda, einschliesslich des Erstellens, Bearbeitens und Löschens von Kalendereinträgen sowie den Start des Lernalgorithmus.
        \item \textbf{\texttt{grades.py}}: Beinhaltet die API für das Notenmanagement.
        \item \textbf{\texttt{main.py}}: Definiert die Hauptrouten der Webseite, wie die Startseite.
        \item \textbf{\texttt{settings.py}}: Steuert die Einstellungsseite und die zugehörige Speicherlogik.
    \end{itemize}

    \item \textbf{Datenbankmodelle (\texttt{kkoala/models.py})}:
    Alle SQLAlchemy-Datenbankmodelle (z.B. \texttt{User}, \texttt{Event}, \texttt{Semester}) sind zentral in dieser Datei definiert. Dies erleichtert die Verwaltung der Datenstruktur und Beziehungen.

    \item \textbf{Kernlogik und Hilfsfunktionen}:
    \begin{itemize}
        \item \textbf{\texttt{kkoala/algorithms.py}}: Eine dedizierte Datei, die ausschliesslich die komplexe Logik des Lernzeitalgorithmus (LZA) enthält.
        \item \textbf{\texttt{kkoala/utils.py}}: Beinhaltet wiederverwendbare Hilfsfunktionen und sogenannte \enquote{Decorators}. Die wichtigsten sind:
    \begin{itemize}
        \item \textbf{\texttt{@login\_required}}: Dieser Decorator wird über Routen platziert, die nur von angemeldeten Benutzern aufgerufen werden dürfen. Er prüft automatisch, ob ein Benutzer in der aktuellen Sitzung (Session) angemeldet ist. Falls nicht, wird der Benutzer zur Login-Seite umgeleitet. 
        \item \textbf{\texttt{@csrf\_protect}}: Schützt Formulare und API-Endpunkte vor Cross-Site Request Forgery Angriffen, wie im Abschnitt \enquote{CSRF-Schutz} beschrieben.
    \end{itemize}
        \item \textbf{\texttt{kkoala/extensions.py}}: Hier werden die Flask-Erweiterungen (SQLAlchemy, Bcrypt, usw.) initialisiert, um zirkuläre Importfehler zu vermeiden.
    \end{itemize}
    
    \item \textbf{Startpunkt (\texttt{wsgi.py}) und die WSGI-Schnittstelle}:
    Die Datei \texttt{wsgi.py} im Hauptverzeichnis ist der standardisierte Einstiegspunkt für den Webserver. Ihre einzige Aufgabe ist es, die \texttt{create\_app}-Factory zu importieren und das daraus resultierende Flask-\texttt{application}-Objekt zu erstellen.

    Dieses Objekt ist entscheidend, da es der WSGI (Web Server Gateway Interface) Spezifikation entspricht. WSGI ist ein Python-Standard, der als universelle Schnittstelle oder \enquote{Brücke} zwischen dem Webserver (der Anfragen aus dem Internet empfängt) und der Webanwendung (unserem Flask-Code) dient. \parencite{chaitanya_srivastav_wsgi}

    Für den produktiven Einsatz unserer App verwenden wir Gunicorn (\enquote{Green Unicorn}), einen robusten und weit verbreiteten WSGI-HTTP-Server. Während der eingebaute Entwicklungsserver von Flask für das Testen ausreicht, ist er nicht dafür ausgelegt, eine hohe Anzahl von Anfragen zu bewältigen. Gunicorn agiert hier als leistungsfähiger \enquote{Middleman} zwischen dem Internet und unserer Flask-Anwendung. Er kann mehrere Anfragen gleichzeitig bearbeiten, indem er mehrere \enquote{Worker}-Prozesse verwaltet, was die Leistung und Stabilität der Anwendung unter Last sicherstellt. \parencite{codesignal_gunicorn} Wenn wir Gunicorn starten, geben wir ihm den Befehl \texttt{gunicorn wsgi:application}. Er weiss dann, dass er in der Datei \texttt{wsgi.py} nach dem \texttt{application}-Objekt suchen und dieses als Startpunkt für die Anwendung verwenden muss.
\end{enumerate}

% ------------------------------Frontend-Struktur (Templates und Statische Dateien)------------------------------
\subsection{Frontend-Struktur (Templates und Statische Dateien)}
Die Benutzeroberfläche der Kanti Koala App wird dynamisch auf dem Server generiert und als fertige HTML-Seiten an den Browser des Nutzers gesendet.

\begin{itemize}
    \item \textbf{Templates (\texttt{kkoala/templates/})}:
    In diesem Verzeichnis befinden sich alle HTML-Dateien der Anwendung. Flask verwendet die Template-Engine Jinja, um diese Dateien zu verarbeiten. Jinja ermöglicht es, Python-Code direkt in HTML einzubetten, zum Beispiel um Schleifen zu erstellen (\texttt{\{\% for item in items \%\}}), bedingte Blöcke anzuzeigen (\texttt{\{\% if user.is\_authenticated \%\}}) oder Variablen aus dem Backend auszugeben (\texttt{\{\{ user.username \}\}}). Dies macht die Seiten dynamisch und personalisiert. \parencite{jinja_templates, flask_templating}

    \item \textbf{Statische Dateien (\texttt{kkoala/static/})}:
    Dieses Verzeichnis enthält alle statischen Assets, die vom Browser direkt geladen werden, ohne dass der Server sie verarbeiten muss. Dazu gehören:
    \begin{itemize}
        \item \textbf{CSS-Dateien}: Für das Styling und das visuelle Design der Anwendung.
        \item \textbf{Bilder}: Logos und andere grafische Elemente.
    \end{itemize}
\end{itemize}

\section{Features}
Zunächst werden alle Entscheidungen über die Features erklärt. Natürlich werden die Features auch erklärt.

% ------------------------------DATENBANK------------------------------
\subsection{Datenbank}
Da es sich um eine Webanwendung handelt, können nicht alle Informationen des Benutzers lokal gespeichert werden. Das bedeutet erstens, dass alle Informationen extern auf einem Server gespeichert werden müssen. Zweitens erfordert der Mehrbenutzerbetrieb eine nutzerspezifisch getrennte, zentrale Datenhaltung; die ausschliessliche Speicherung der Daten eines einzelnen Nutzers, wie bei lokaler Nutzung, ist nicht ausreichend. Das bedeutete für uns zwei Dinge. Wir müssen einen Weg finden, die Informationen zu speichern, und wir müssen herausfinden, wo diese Informationen gespeichert werden sollen.

Um die Informationen zu speichern, haben wir uns für SQL-Datenbanken entschieden, da diese am einfachsten mit Flask zu verwenden sind. \parencite{flask_database_tutorial} Wenn wir lokal arbeiten, können wir SQLite verwenden, und wenn es sich um die Produktionsumgebung handelt, können wir PostgreSQL verwenden, welches viel besser ist für eine solche Umgebung \parencite{astera_postgres_vs_sqlite}.

Die Struktur dieser Tabellen ist im Folgenden dargestellt:

% --- SCHEMA DESCRIPTION REPLACING TABLES ---
\subsubsection[Datenbankmodelle und Schema]{Datenbankmodelle und Schema\texorpdfstring{\aifootnotemark}{}}
\footnotetext{ChatGPT (Version GPT-5): \enquote{Describe the models from models.py in LaTeX in German, without using tables. Just use text. }, 04.11.2025. Antwort ganz übernommen.}
Die Datenbank besteht aus sieben Hauptmodellen, die die Nutzerdaten und die Planungslogik abbilden.

\myparagraph{User}
Dieses Modell speichert die Authentifizierungsdetails und dient als zentraler Ankerpunkt für alle anderen Daten des Nutzers.
\begin{description}
    \item[\textbf{id}] Eindeutige ID des Nutzers (Primary Key).
    \item[\textbf{username}] Der gewählte Benutzername (eindeutig, notwendig).
    \item[\textbf{password}] Das gehashte Passwort (notwendig).
    \item[\textbf{email}] Die E-Mail-Adresse des Nutzers (eindeutig, notwendig).
\end{description}

\myparagraph{Settings}
Speichert globale Einstellungen für den Lernalgorithmus, die dem \texttt{User} zugeordnet sind.
\begin{description}
    \item[\textbf{id}] Eindeutige ID (Primary Key).
    \item[\textbf{user\_id}] Fremdschlüssel zur \texttt{User}-Tabelle (notwendig).
    \item[\textbf{learn\_on\_saturday}] Boolesche Variable, ob am Samstag gelernt werden soll (Standard: False).
    \item[\textbf{learn\_on\_sunday}] Boolesche Variable, ob am Sonntag gelernt werden soll (Standard: False).
    \item[\textbf{preferred\_learning\_time}] Bevorzugte Startzeit für Lernblöcke (Standard: 18:00).
    \item[\textbf{study\_block\_color}] Hex-Code für die Farbe der Lernblöcke (Standard: \#0000FF).
\end{description}

\myparagraph{PrioritySetting}
Definiert die spezifischen Parameter für jede Prioritätsstufe des Lernalgorithmus.
\begin{description}
    \item[\textbf{id}] Eindeutige ID (Primary Key).
    \item[\textbf{settings\_id}] Fremdschlüssel zur \texttt{Settings}-Tabelle (notwendig).
    \item[\textbf{priority\_level}] Die Prioritätsstufe (Integer, notwendig).
    \item[\textbf{color}] Die dem Prioritätslevel zugeordnete Farbe (Hex-Code, notwendig).
    % \item[\textbf{days\_to\_learn}] Anzahl der Tage vor einem Ereignis, an denen gelernt werden soll.
    \item[\textbf{max\_hours\_per\_day}] Maximale Lernstunden pro Tag für diese Priorität.
    \item[\textbf{total\_hours\_to\_learn}] Die gesamte zu lernende Stundenanzahl für diese Priorität.
\end{description}

\myparagraph{Event}
Speichert Kalendereinträge des Nutzers sowie Metadaten für den Planungsalgorithmus.
\begin{description}
    \item[\textbf{id}] Eindeutige ID (Primary Key).
    \item[\textbf{user\_id}] Fremdschlüssel zur \texttt{User}-Tabelle (notwendig).
    \item[\textbf{title}] Titel des Ereignisses.
    \item[\textbf{start}] Startzeitpunkt im ISO-Format (notwendig).
    \item[\textbf{end}] Endzeitpunkt im ISO-Format (optional).
    \item[\textbf{color}] Farbe des Ereignisses.
    \item[\textbf{priority}] Prioritätsstufe (Integer).
    \item[\textbf{recurrence}] Wiederholungsregel des Ereignisses.
    \item[\textbf{recurrence\_id}] Eindeutige ID zur Gruppierung wiederkehrender Ereignisse.
    \item[\textbf{all\_day}] Boolesche Variable, ob das Ereignis ganztägig ist (Standard: False).
    \item[\textbf{locked}] Boolesche Variable für den Algorithmus; \texttt{True} bedeutet, das Ereignis ist fixiert (Standard: True).
    \item[\textbf{exam\_id}] ID des zugehörigen Examens, falls zutreffend.
\end{description}

\myparagraph{Semester, Subject und Grade}
Diese Modelle bilden die akademische Hierarchie ab.
\begin{description}
    \item[\textbf{Semester}] Speichert akademische Abschnitte. Enthält \textbf{user\_id} (Fremdschlüssel) und \textbf{name}.
    \item[\textbf{Subject}] Speichert Fächer innerhalb eines Semesters. Enthält \textbf{semester\_id} (Fremdschlüssel) und \textbf{name}.
    \item[\textbf{Grade}] Speichert Bewertungen für Fächer. Enthält \textbf{subject\_id} (Fremdschlüssel), \textbf{name}, \textbf{value}, \textbf{weight} und \textbf{counts}.
\end{description}

% --- RELATIONSHIPS TEXT (KEPT AS-IS) ---
Die Daten in der Datenbank werden unten erklärt. Was wichtig bei den Datenbanken ist, ist dass die beiden Datenbanken zusammen verbunden sind, mithilfe eines Foreign Keys. Dieser Foreign Key befindet sich in der Eventdatenbank, unter dem Name \enquote{user\_id}. Dieser sagt uns, welcher Event zu welchem User gehört.

\paragraph{Beziehungsstruktur}
Die Abhängigkeiten und Kaskadenlöschungen (z.B. ein gelöschter \texttt{User} löscht alle seine \texttt{Events}, \texttt{Semesters} und \texttt{Settings}) sind über Fremdschlüsselverweise in allen untergeordneten Tabellen implementiert. Die zentralen Verbindungen sind:
\begin{itemize}
    \item \texttt{User} $\to$ \texttt{Settings} (1:1), \texttt{Events} (1:n), \texttt{Semester} (1:n)
    \item \texttt{Settings} $\to$ \texttt{PrioritySetting} (1:n)
    \item \texttt{Semester} $\to$ \texttt{Subject} (1:n)
    \item \texttt{Subject} $\to$ \texttt{Grade} (1:n)
\end{itemize}

% ------------------------------SERVER------------------------------
\subsection[Serververbindung]{Serververbindung\texorpdfstring{\aifootnotemark}{}}
\footnotetext{ChatGPT (Version GPT-5): \enquote{Korriegiere Grammatik und Rechtschreibfehler im folgenden Text. [...]. }, 04.11.2025. Antwort ganz übernommen.}
Da es um eine Web-App handelt, müssen die SQL-Datenbanken irgendwo extern gespeichert werden, wo man sie jederzeit abrufen kann. Das heisst, die SQL-Datei muss auf ein Server gespeichert werden. Wir haben uns schliesslich für die Cloud-Applikation \enquote{DigitalOcean} entschieden. Der Grund dafür war, weil wir erhalten gratis Credits mit einem Student Developer Pack. Gleichzeitig konnten wir auch die Webseite auf derselben Plattform hosten, welches den Prozess vereinfacht hat, da wir alles intern verbinden konnten.

Die Domain, die wir kauften, wurde wegen dem gleichen Grund gekauft, nämlich, dass wir mit demselben Student Developer Pack die Top-Level-Domain .app gratis erhalten haben. Die Domain heisst \href{https://www.kantikoala.app}{kantikoala.app}.

% ------------------------------AUTHENTIFICATION------------------------------
\subsection[Authentifizierung]{Authentifizierung\texorpdfstring{\aifootnotemark}{}}
\aifootnotebasis{04.11.2025}
Um eine App mit verschiedenen Nutzern zu haben, brauchen wir ein gutes Authentifizierungssystem. Das bedeutet, dass es eine Anmelde- und Registrierungsfunktion sowie eine Option zum Vergessen des Passworts, eine Option zum Ändern des Passworts und schliesslich auch eine Option zum Löschen des Kontos geben muss. 

Natürlich können wir ein Passwort nicht im Klartext speichern, denn das wäre ein Sicherheitsrisiko und ein ethisches Risiko, weil wir als Entwickler dann die Passwörter der einzelnen Konten einsehen können. Die einfachste Lösung für dieses Problem besteht darin, das Kennwort zu hashen. Unter Passwort-Hashing versteht man die algorithmische Umwandlung eines Passworts in Chiffretext oder eine unumkehrbar verschleierte Version seiner selbst \parencite{password_hashing}. Ein anderes wichtiges Konzept ist das Salting. Salting ist die Praxis, zufällige Daten (ein \enquote{Salt}) zu einem Passwort hinzuzufügen, bevor es gehasht wird. Dies verhindert Angriffe mit vorgefertigten Tabellen (Rainbow Tables), da das gleiche Passwort mit unterschiedlichen Salts zu unterschiedlichen Hashes führt \parencite{password_salting_rainbow_tables}. Glücklicherweise kümmert sich das Flask-Bcrypt-Modul um all diese Dinge für uns, sodass wir uns keine Sorgen machen müssen, wie wir das Passwort hashen und salten. \parencite{flask_bcrypt_docs}

Sobald man sich anmeldet oder registriert, wird man auf die Startseite der Website weitergeleitet.

Sehr wichtig bei jedem Anmeldesystem ist natürlich eine Option das Passwort zurückzusetzen wenn man es vergisst. Um so ein System zu haben, ist es wichtig, dass man den Link, um das Passwort zurückzusetzen, nur einmal verwenden kann. Um dies zu erreichen, haben wir den Token, welches gebraucht wird, um zu überprüfen, dass das Passwort für den richtigen User zurückgesetzt wird, mit dem Hash vom alten Passworts generiert. Wir sind dank \textcite{password_reset} auf diese Idee gekommen. Das Prinzip funktioniert, da das Passwort sich ändern wird, und somit kann man den gleichen Token nicht wieder verwenden. Zudem brauchen wir, um die E-Mail zu verschicken, eine API, damit wir sie mit unserer eigenen Domaine verschicken können. Wir haben uns für die API von Resend entschieden, da sie eine kostenlose Stufe hat, die für unser Projekt ausreicht.

Im Falle, dass ein Nutzer zum Beispiel mit einer E-Mail, die schon gebraucht wird, sich registrieren will, oder mit einem falschen Passwort sich anmelden will, bekommt der Nutzer eine Fehlermeldung angezeigt, die ihm sagt, was falsch gelaufen ist, mithilfe von Flash-Nachrichten, welche eine Funktion von Flask ist \parencite{realpython_flask_flashes}.

%\href{https://freelancefootprints.substack.com/p/yet-another-password-reset-tutorial}{Yet another password reset tutorial}
%------------------------------AGENDA------------------------------
\subsection[Agenda]{Agenda\texorpdfstring{\aifootnotemark}{}}
\aifootnotebasis{04.11.2025}
Die Agenda ist eine zentrale Kernfunktion der Anwendung. Sie muss intuitiv bedienbar sein und mindestens die folgenden Operationen unterstützen: das Erstellen, Bearbeiten und Löschen von Terminen.

Jedes Ereignis umfasst die Attribute Titel, Start- und Endzeit, eine optionale Wiederholungsregel, eine Farbe sowie eine Priorität, die für den Lernzeitalgorithmus relevant ist. Zusätzlich kann ein Ereignis als ganztägig gekennzeichnet werden. Die Zuordnung zum jeweiligen Konto erfolgt über die aktuell authentifizierte Sitzung; die Benutzer-ID wird beim Anlegen eines Ereignisses automatisch hinterlegt.

Für die Darstellung setzen wir die JavaScript-Bibliothek FullCalendar ein. Wir haben uns für dieses Modul entschieden, weil es das erste Ergebnis war, das bei der Suche nach einer Bibliothek mit seinen Fähigkeiten auftauchte.

Zudem unterstützt die Agenda den Import des individuellen Stundenplans aus \texttt{schulnetz}, der von der Kantonsschule zur Anzeige von Stundenplänen genutzt wird. Da \texttt{schulnetz} Kalenderdaten im \texttt{.ics}-Format exportiert, kann die Datei zunächst dort exportiert und anschliessend in unsere Anwendung importiert werden. Dies reduziert manuellen Erfassungsaufwand.

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{img/agenda.png}
    \caption[Beispiel einer Agenda mit Lernblöcken der LZA. Screenshot Kanti Koala, 31.10.2025]{Beispiel einer Agenda mit Lernblöcken der LZA}
    \label{fig:placeholder}
\end{figure}
% ------------------------------ALGORITHMUS------------------------------
\subsection[Der Lernzeitalgorithmus]{Der Lernzeitalgorithmus\texorpdfstring{\aifootnotemark}{}}
\footnotetext{ChatGPT (Version GPT-5): \enquote{Korriegiere Grammatik und Rechtschreibfehler im folgenden Text. [...]. }, 04.11.2025. Antwort ganz übernommen.}
Der Lernzeitalgorithmus (LZA) ist der Kern unserer Web-App. Er automatisiert die Planung der notwendigen Lernzeiten für die anstehenden Prüfungen eines Nutzers.
Wir bezeichnen unseren Mechanismus als Algorithmus, da er die formalen Kriterien eines Algorithmus erfüllt: Jeder Planungsschritt ist ausführbar (existierende Funktionen), deterministisch und determiniert (gleiche Eingabedaten führen stets zur gleichen Priorisierung und Planung). Zudem ist die Anzahl der zur Erstellung des Lernplans notwendigen Schritte endlich (Finitheit), wodurch der Mechanismus garantiert terminiert und eine strukturierte Ausgabe (den Lernplan) basierend auf den Eingabedaten (Benutzereinstellungen und Prüfungstermine) liefert. \parencite{studyflix_algorithmus}

\subsubsection{Eingabeparameter und Planungsziel}

Der Lernzeitalgorithmus (LZA) verwendet globale Benutzereinstellungen sowie prüfungsspezifische Prioritätseinstellungen als Eingabeparameter, um eine optimale Lernplanung zu gewährleisten.

Das zentrale Planungsziel des LZA ist es, die definierten totale Lernstunden für jede Prüfung innerhalb des gültigen Lernfensters zu erreichen, während das tägliche Maximum und alle bestehenden Kalenderkonflikte des Nutzers strikt eingehalten werden.

\myparagraph{Globale Parameter}
Diese Einstellungen gelten für den gesamten Planungszeitraum:
\begin{itemize}
    \item \textbf{Lernen am Samstag}\\
    Definiert, ob der Algorithmus Lernblöcke an Samstagen planen darf.
    \item \textbf{Lernen am Sonntag}\\
    Definiert, ob der Algorithmus Lernblöcke an Sonntagen planen darf.
    \item \textbf{Bevorzugte Lernzeit}\\
    Die bevorzugte Uhrzeit am Tag, zu der die Platzierung von Lernblöcken primär angestrebt wird.
\end{itemize}

\myparagraph{Prüfungsspezifische Parameter (Pro Prioritätstufe)}
Diese Werte werden basierend auf der Priorität jeder Prüfung zugewiesen:
\begin{itemize}
    % \item \textbf{Lernfenster}\\
    % Die Anzahl der Tage rückwirkend ab dem Prüfungstermin, innerhalb derer Lernblöcke platziert werden sollen.
    \item \textbf{Tägliches Maximum}\\
    Die maximale Stundenzahl, die pro Tag für Prüfungen dieser Priorität geplant werden darf.
    \item \textbf{Total Lernstunden}\\
    Die gesamte Anzahl an Lernstunden, die für Prüfungen dieser Priorität absolviert werden muss.
\end{itemize}

\subsubsection{Ablauf und Planungsstrategie}
Der Algorithmus arbeitet iterativ und bearbeitet alle als Prüfung markierten Ereignisse in aufsteigender Reihenfolge ihrer Priorität. Eine niedrigere Prioritätsnummer kennzeichnet dabei eine höhere Wichtigkeit, um eine optimale Ressourcenverteilung zu gewährleisten.

\begin{enumerate}
    \item \textbf{Zyklische Neuberechnung der Anforderungen (Recycling)}:
    \begin{itemize}
        \item \textbf{Flexibilitätsbereinigung}: Alle vom System selbst geplanten, aber nicht gesperrten (gesperrt sind die Blöcke, die vom Nutzer bearbeitet worden sind) Lernblöcke für die aktuelle Prüfung werden gelöscht. Dies ermöglicht eine Neuplanung, falls sich die Rahmenbedingungen (z.B. neue Events, geänderte Prioritätseinstellungen) geändert haben.
        \item \textbf{Soll-Stunden-Ermittlung}: Die noch zu erbringende Lernzeit wird neu berechnet. Hierbei werden alle bereits absolvierten Stunden sowie Stunden, die durch manuelle oder vom Nutzer gesperrte Blöcke abgedeckt sind, von den Gesamtsollstunden abgezogen.
    \end{itemize}
    \item \textbf{Rückwärts-Iterative Planung}:
    \begin{itemize}
        \item Die Planungsstrategie ist eine Rückwärtsiteration: Sie beginnt beim Prüfungstermin und arbeitet sich tageweise, jedoch maximal drei Wochen, bis zum aktuellen Datum vor. Diese Zeitspanne wurde auf Basis unserer Recherche als optimaler Zeitraum für eine effektive Prüfungsvorbereitung festgelegt. Dieses Vorgehen stellt sicher, dass die Lernblöcke mit höchster Dringlichkeit (die Tage, die am nächsten zur Prüfung liegen) zuerst belegt werden.
        \item An jedem Tag wird die maximale Lernzeit für diese spezifische Prüfung ermittelt. Diese ergibt sich aus der Differenz zwischen dem täglichen Maximum und den Stunden, die bereits an diesem Tag für die Prüfung geplant wurden. Dadurch wird das tägliche Zeitlimit zuverlässig eingehalten und eine Überlastung vermieden.
    \end{itemize}
    \item \textbf{Platzierung und strikte Konfliktvermeidung}:
    \begin{itemize}
        \item \textbf{Bevorzugter Slot}: Es wird primär versucht, einen Lernblock in der vom Nutzer festgelegten bevorzugten Lernzeit zu platzieren.
        \item \textbf{Konfliktprüfung}: Die Verfügbarkeit des Slots wird gegen alle Kalendereinträge des Nutzers für den aktuellen Tag geprüft. Dabei wird ein 30-minütiger Puffer vor und nach jedem bestehenden Ereignis (wie Sport oder Arzttermin) beachtet, um knappe Überlappungen und unnötigen Stress zu vermeiden.
        \item \textbf{Alternative Slots}: Falls die bevorzugte Zeit belegt ist, sucht eine dedizierte Funktion den grössten verfügbaren, konfliktfreien Zeitabschnitt des Tages, um die Platzierung zu maximieren.
        \item \textbf{Echtzeit-Aktualisierung}: Nach der erfolgreichen Generierung und Speicherung eines Lernblocks wird dieser sofort zur Liste der aktuellen Kalenderereignisse hinzugefügt. Dieser Mechanismus ist entscheidend, um sicherzustellen, dass alle unmittelbar nachfolgenden Planungsversuche am selben Tag diesen neu erstellten Block als bereits belegt berücksichtigen und somit Überlappungen ausgeschlossen sind.
    \end{itemize}
    % \item \textbf{Notfallplanung (Erweitertes Zeitfenster)}:
    % \begin{itemize}
    %     \item Falls die Gesamtlernstunden nach der iterativen Planung im primären Lernfenster noch nicht erreicht wurden, aktiviert der Algorithmus eine Notfallsuche.
    %     \item Diese sucht nach verfügbaren Plätzen in einem erweiterten, sekundären Zeitfenster. Dieses Fenster erstreckt sich maximal bis zum 21. Tag vor der Prüfung.
    %     \item Die Regeln des täglichen Maximums und der Konfliktvermeidung bleiben auch in diesem Notfallmodus strikt erhalten.
    % \end{itemize}
    \item \textbf{Ergebnisrückgabe und Zusammenfassung}:
    \begin{itemize}
        \item Nachdem alle Prüfungen bearbeitet wurden, gibt der Algorithmus eine detaillierte Zusammenfassung des Planungsvorgangs zurück.
        \item Diese Zusammenfassung informiert den Nutzer in einem Popup über die Gesamtzahl der hinzugefügten Lernblöcke und die Gesamtstunden, die erfolgreich geplant wurden.
        \item Zusätzlich wird für jede einzelne Prüfung der Planungsstatus (erfolgreich / nicht erfolgreich) und die geplante Stundenanzahl angezeigt.
    \end{itemize}
\end{enumerate}


% ------------------------------DAILY TIPS------------------------------
\subsection{Daily Tipps}
Ein relativ wichtiges Feature unserer App sind die Daily Tipps. Es sollte jeden Tag ein neuer Tipp an den Nutzer gezeigt werden auf der Startseite, entweder über die Kantonsschule oder allgemeine Lerntipps. Die einfachste Möglichkeit, dies zu implementieren, ist eine simple Modulo-Rechnung. 
\[
\text{Tipp des Tages (Index von der Liste)} = (\text{Tag des Jahres}) \bmod (\text{Anzahl der Tipps})
\]

Somit wird an einem bestimmten Tag nur einen Tipp gezeigt und über das ganze Jahr sollten alle Tipps in einem Zyklus gezeigt werden (da wir sowieso weniger als 365 Tipps haben).


% ------------------------------NOTENORGANISATION------------------------------

\subsection{Notenorganisation}
In der Kantonsschule muss man immer wieder Prüfungen schreiben. Die Noten, die man erhält, sind dann wichtig für die Promotion in die nächste Stufe. Deswegen haben wir ein Feature, in dem man seine Noten pro Semester speichern kann. Jedes Semester hat schon die jeweiligen Fächer, die man dann in diesem Semester haben würde, geladen. Man kann natürlich immer noch Fächer löschen und hinzufügen. Man kann mit diesem Feature dann seine Durchschnitte pro Fach und Semester sehen. Ebenfalls kann man mit dem Notenrechner sehen, welche Note man in einem Fach brauchen würde, um einen bestimmten Schnitt in diesem Fach zu haben. Die Idee von diesem Feature stammt aus der App \enquote{Pluspoints} \parencite{pluspoints_app}. Das Feature, das uns dort fehlte, war die automatische Fächeraddition pro Semester, welches wir in unserer App implementiert haben.

% ------------------------------LERNTIMER------------------------------
\subsection{Lerntimer}
Ein weiteres wichtiges Feature unserer App ist der Lerntimer. Dieser Timer basiert auf der Pomodoro-Technik, welche im Recherche Teil dieses Bericht erklärt wurde. Mit der Recherche, die wir führten, fanden wir es wichtig, ein solcher Lerntimer zu implementieren, da es eine sehr effektive Lerntechnik ist. Der Timer hat die Standard-Einstellungen von 25 Minuten Lernen und 5 Minuten Pause, welche man aber auch ändern kann, falls man das möchte.

% ------------------------------LERNTIPPS------------------------------
\subsection{Lerntipps}
Ein weiteres Feature unserer App sind die Lerntipps. Diese sind in verschiedene Kategorien aufgeteilt, wie zum Beispiel Zeitmanagement, Pausenmanagement, Stressmanagement und Lernmethoden. In jeder Kategorie gibt es verschiedene Tipps, welche wir aus unserer Recherche und den Interviews gesammelt haben. Diese Tipps sollen den Nutzer:innen helfen, ihr Lernverhalten zu verbessern.

\section[Sicherheitskonzept]{Sicherheitskonzept\texorpdfstring{\aifootnotemark}{}}
\footnotetext{ChatGPT (Version GPT-5): \enquote{Korriegiere Grammatik und Rechtschreibfehler im folgenden Text. [...]. }, 04.11.2025. Antwort ganz übernommen.}
Neben der reinen Authentifizierung wurden weitere grundlegende Sicherheitsmassnahmen implementiert, um die Daten der Nutzer und die Integrität der Anwendung zu schützen.

\subsection[Datenspeicherung und Passwort-Sicherheit]{Datenspeicherung und Passwort-Sicherheit\texorpdfstring{\aifootnotemark}{}}
\footnotetext{ChatGPT (Version GPT-5): \enquote{Korriegiere Grammatik und Rechtschreibfehler im folgenden Text. [...]. }, 04.11.2025. Antwort ganz übernommen.}
Die Sicherheit der Benutzerdaten hat höchste Priorität. Wie im Abschnitt zur Authentifizierung beschrieben, werden Passwörter niemals im Klartext gespeichert. Stattdessen wird die Flask-Bcrypt-Bibliothek verwendet, um von jedem Passwort einen kryptografischen Hash zu erzeugen. Beim Login-Vorgang wird das eingegebene Passwort ebenfalls gehasht und dieser Hash wird mit dem in der Datenbank gespeicherten Hash verglichen. Da dieser Prozess unumkehrbar ist, kann selbst bei einem direkten Zugriff auf die Datenbank das ursprüngliche Passwort nicht wiederhergestellt werden.

\subsection[Transportverschlüsselung (HTTPS)]{Transportverschlüsselung (HTTPS)\texorpdfstring{\aifootnotemark}{}}
\footnotetext{ChatGPT (Version GPT-5): \enquote{Korriegiere Grammatik und Rechtschreibfehler im folgenden Text. [...]. }, 04.11.2025. Antwort ganz übernommen.}
Die gesamte Kommunikation zwischen dem Browser des Nutzers und unserem Server wird durch das HTTPS-Protokoll verschlüsselt. Dies wird durch ein SSL/TLS-Zertifikat realisiert, das auf unserem Server bei DigitalOcean installiert ist. Die Verschlüsselung stellt sicher, dass alle übertragenen Daten, von Login-Informationen über Kalendereinträge bis hin zu Noten, vor dem Abhören durch Dritte geschützt sind. Ein Angreifer in einem öffentlichen WLAN könnte beispielsweise die Daten nicht mitlesen. Der Browser zeigt dies durch ein Schlosssymbol in der Adressleiste an und garantiert so eine sichere Verbindung zur Domain \texttt{kantikoala.app}. \parencite{cloudflare_https}

\subsection[CSRF-Schutz]{CSRF-Schutz\texorpdfstring{\aifootnotemark}{}}
\footnotetext{ChatGPT (Version GPT-5): \enquote{Korriegiere Grammatik und Rechtschreibfehler im folgenden Text. [...]. }, 04.11.2025. Antwort ganz übernommen.}
Neben der reinen Authentifizierung ist es entscheidend, die Aktionen eines angemeldeten Benutzers abzusichern. Eine häufigste Schwachstelle in Webanwendungen ist die Cross-Site Request Forgery (CSRF) \parencite{rapid7_csrf}. Bei einem CSRF-Angriff bringt ein Angreifer den Browser eines authentifizierten Benutzers dazu, eine unerwünschte Aktion in einer Webanwendung auszuführen, bei der der Benutzer gerade angemeldet ist. Dies geschieht, ohne dass der Benutzer es merkt. So könnte ein Angreifer beispielsweise einen Benutzer dazu verleiten, auf einen bösartigen Link zu klicken, der im Hintergrund unbemerkt das Passwort des Benutzers ändert oder sein Konto löscht. \parencite{TestDriven_CSRF}

Um dies zu verhindern, haben wir das \enquote{Synchronizer Token Pattern} implementiert, eine von \textcite{OWASP_CSRF} empfohlene Methode. Das Prinzip ist einfach, aber sehr wirksam:
\begin{enumerate}
    \item Für jede Benutzersitzung wird ein einzigartiges, geheimes und unvorhersehbares Token generiert und auf dem Server gespeichert.
    \item Dieses Token wird in alle Formulare, die eine Zustandsänderung bewirken (z.B. das Ändern von Einstellungen oder das Löschen eines Kontos), als verstecktes Feld eingebettet.
    \item Wenn der Benutzer das Formular abschickt, wird das Token zusammen mit den anderen Formulardaten an den Server gesendet.
    \item Der Server vergleicht das vom Client gesendete Token mit dem in der Sitzung gespeicherten Token. Stimmen die beiden nicht überein, wird die Anfrage abgelehnt.
\end{enumerate}
Da ein Angreifer auf einer fremden Website dieses geheime Token nicht kennen kann, schlägt der Fälschungsversuch fehl.

In unserer Flask-Anwendung haben wir diese Logik mithilfe eines eigenen Decorators (\texttt{@csrf\_protect}) umgesetzt. Dieser Decorator wird auf alle Routen angewendet, die Daten durch \texttt{POST}-, \texttt{PUT}- oder \texttt{DELETE}-Anfragen ändern. Bei Standard-HTML-Formularen wird das Token als verstecktes \texttt{<input>}-Feld übergeben. Für unsere dynamischen Agenda-Funktionen, die auf AJAX basieren, wird das Token aus einem Meta-Tag ausgelesen und in einem benutzerdefinierten HTTP-Header (\texttt{X-CSRF-Token}) mit jeder Anfrage gesendet. Dies stellt sicher, dass jede datenverändernde Aktion, die in unserer Applikation ausgeführt wird, legitim vom Benutzer und von unserer eigenen Webseite stammt.

Eine wichtige Anmerkung ist, dass es schon Module wie \texttt{Flask-WTF} gibt, die CSRF-Schutz bieten. Wir haben uns jedoch entschieden, unseren eigenen Decorator zu schreiben, um ein tieferes Verständnis für die Funktionsweise von CSRF-Schutzmechanismen zu erlangen.

% ------------------------------TESTS------------------------------
\section{Tests}
Um die Qualität und Zuverlässigkeit der Kanti Koala Web-App sicherzustellen, wurden verschiedene Testfälle erstellt. Diese Tests decken sowohl die Backend-Logik als auch die Frontend-Funktionalität ab. Die genauen Testfälle und deren Ergebnisse sind im Anhang dokumentiert. 


% Schlussfolgerung und Ausblick
%\clearpage
\chapter[Schlussfolgerung und Ausblick]{Schlussfolgerung und Ausblick\texorpdfstring{\aifootnotemark}{}}
\aifootnotetext{06.11.2025}
\section*{Zusammenfassung}
% Folgende Linie zu überarbeiten:
Ausgehend von der in der Einleitung formulierten Zielsetzung -- Übersicht über Termine/Aufgaben/Lernzeiten schaffen und regelmässige, abgegrenzte Lernphasen unterstützen -- wurde ein prototypischer Web-Ansatz umgesetzt. Die zuvor durch Literaturstudie (Lern-, Zeit-, Pausen-, Stressaspekte), Interviews mit PPP-Lehrpersonen und eine Schüler:innen-Umfrage gewonnenen Erkenntnisse dienten der Ableitung der funktionalen Kernanforderungen (zentrale Agenda, automatische Lernblock-Erzeugung, strukturierte Zeitsegmente, einfache Notenerfassung, Basis-Schutzmechanismen).

Umgesetzt wurden:
\begin{itemize}
  \item \textbf{Agenda} als zentrales Organisationsinstrument mit manueller Event-Erfassung, Import von \texttt{.ics}-Stundenplänen und Prioritätsattributen als Grundlage für Lernblöcke (reduziert Mehrfacherfassung).
  \item \textbf{Lernzeitalgorithmus} mit rückwärtsgerichteter, konfliktvermeidender Platzierung von Lernblöcken innerhalb täglicher Obergrenzen und gesetzter Prioritäten (unterstützt regelmässige, zeitlich definierte Phasen).
  \item \textbf{Notenverwaltung} (Semester-Fach-Note) zur strukturierten Ablage schulischer Leistungsdaten (fördert konsistente Dokumentation).
  \item \textbf{Pomodoro-basierter Lerntimer} zur zeitlichen Segmentierung von Lernintervallen und Pausen (Rahmen für wiederholbare Lerngewohnheiten).
  \item \textbf{Tägliche Tipps} aus recherchierten Bereichen (Zeit-, Pausen-, Stressmanagement, Lernmethoden) als ergänzende Impulse.
  \item \textbf{Authentifizierung} (Registrierung, Login, Passwort-Reset) mit gehashten/gesalzten Passwörtern (bcrypt) zur sicheren Zugangstrennung.
  \item \textbf{Basis-Sicherheitsmassnahmen} (CSRF-Token, HTTPS-Kommunikation) zur Integrität von Sitzungsaktionen und Schutz der Transportstrecke.
\end{itemize}
Damit liegt ein kohärenter Prototyp vor, der die in der Einleitung definierten organisatorischen und lerngewohnheitsbezogenen Zielkomponenten funktional realisiert; Aussagen zur tatsächlichen Wirkung im Nutzungskontext stehen aus.

\section*{Bilanz zur Fragestellung}
Die Hauptfragestellung (Erleichterung von Organisation und Unterstützung regelmässiger Lerngewohnheiten) wurde technisch adressiert:
\begin{itemize}
  \item \textbf{Organisation erleichtern}: Zentrale Erfassung von Ereignissen, algorithmische Erstellung von Lernblöcken, Prioritätssteuerung und .ics-Import reduzieren manuellen Planungsaufwand (keine Mehrfacherfassung, automatische zeitliche Segmentierung vom Algorithmus).
  \item \textbf{Unterstützung von Lerngewohnheiten}: Strukturierte Lernblöcke (mit Start-/Endzeiten) und konfigurierbarer Lerntimer bilden wiederkehrende Einheiten ab; Lerntipps liefern ergänzende Handlungsimpulse.
\end{itemize}
Nicht beantwortet ist die empirische Wirksamkeit (keine Nutzerstudie, keine Auswertung von Termintreue oder wahrgenommener Kontrolle). Die Plattformfrage wurde faktisch zugunsten einer Web-Variante getroffen; eine systematische Gegenüberstellung zu einer nativen Umsetzung steht aus.

\section*{Erkenntnisse aus dem Arbeitsprozess}
\begin{itemize}
  \item Früh definierte Datenbeziehungen erleichtern Erweiterungen (z.B. zusätzliche Leistungsmetriken).
  \item Iterative Anpassung des Lernzeitalgorithmus notwendig (Rückwärtsplanung erwies sich zur Priorisierung naher Prüfungen als praktikabel; Konfliktpuffer reduzierten Engstellen).
  \item Klare Prioritätsparameter (tägliches Maximum, Gesamtstunden) verhindern Überlastung, erforderten aber konsistente Validierung.
  \item Modularisierung (Blueprints, \texttt{extensions.py}, Factory) minimierte Kopplung und vereinfachte Tests.
  \item Sicherheitsthemen (CSRF, Passwort-Hashing) müssen früh integriert werden, um Nacharbeiten zu vermeiden.
  \item Transkription in Mundart führte zu hohem Aufwand; Standardisierung der Interviewsprache wäre effizienter.
  \item Heuristische Betrachtung der Bedienlogik ersetzt keine Nutzerbeobachtung.
\end{itemize}

\section*{Ausblick und offene Punkte}
\begin{itemize}
  \item \textbf{Empirische Evaluation}: Erhebung definierter Indikatoren (Planungsaufwand, Termintreue, wahrgenommene Kontrolle) durch Tagebuch- oder Log-Daten und Fragebögen.
  \item \textbf{Algorithmus-Erweiterung}: Adaptive Verteilung basierend auf Notenfortschritt.
  \item \textbf{Plattformvergleich}: Systematische Analyse einer nativen oder hybriden App (Offline-Fähigkeit, Push-Benachrichtigungen).
  \item \textbf{Zusätzliche Sicherheitsmassnahmen}: 2FA, Ratenbegrenzung bei Anmeldeversuchen, E-Mail-Verifizierung.
  \item \textbf{Zusätzliche Features}: Integration von To-Do-Listen, Fortschrittsvisualisierung, soziale Funktionen (z.B. Lerngruppen).
\end{itemize}

\section*{Fazit}
Der Prototyp schafft eine funktionale Grundlage zur strukturierten Erfassung und Planung von schulischen Aktivitäten und Lernzeiten. Die technische Machbarkeit der Kernfunktionen ist gezeigt; die tatsächliche Wirkung auf Lernorganisation und Gewohnheiten bleibt Gegenstand zukünftiger Evaluation. Damit liegt eine belastbare Ausgangsbasis für eine empirische Validierungs- und Erweiterungsphase vor.


% References

%\addcontentsline{toc}{chapter}{Bibliography}
%\nocite{*}
%\printbibliography
\clearpage
\addcontentsline{toc}{chapter}{Literaturverzeichnis} % Changed from Bibliography/Quellen
\nocite{*}
\printbibliography[title={Literaturverzeichnis}]

\clearpage
\listoffigures
\addcontentsline{toc}{chapter}{Abbildungsverzeichnis}

\clearpage
\chapter*{Anhang}
\addcontentsline{toc}{chapter}{Anhang}
\begin{itemize}
    \item \textbf{Code:} Der vollständige Code der Kanti Koala Web-App ist auf GitHub verfügbar unter: \url{https://github.com/CoderAryanAnand/lernapp}.
    \item \textbf{KI-Nachweis}
    \item \textbf{Tests}
    \item \textbf{Umfragen und Interviews}
\end{itemize}


\end{document}
